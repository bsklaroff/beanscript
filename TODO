built in hashmap

implement strings
implement number types other than i32
- figure out defaulting / coercion
- do we need monomorphism restriction?
- multi-param typeclasses?
implement exponent operator

add error handling with pretty error messages
add exceptions

typealias xtype = {a :: atype, b :: btype}
- allow xtype k = {a :: k, b :: int}
object type in typeclass specifies required keys
- allow parsing of object type in typeclass context
- implement by copying key subsets of object args, or log(n) key lookup?
- deal with generalization of fn obj properties
disallow recursive types?
constructed types
- restrict where types can be constructed / unboxed
- disallow conjoining =| clauses with anything other than 'and'
- allow e.g. a =| Just 23
- figure out type defaulting for ambiguous destructed types?
- allow nested destructions
- syntactic sugar: question marks unpack maybes
- deal with unboxed variable scopes
  - restrict to parent if / while statement
  - disallow variable overwriting by unboxing
- allow unpacking of function args
  - allow naming of boxed type with @ notation
  - also allow cases via matchargs
  - ensure cases are exhaustive
fix type inference issues
- redefining fns means the final generalized type is not known until the last
  definition, so if we instantiate a fn before the last definition, the type
  checker will be too permissive
- ensure fn args are not generalized. particularly an issue if an arg is
  reassigned inside a fn
- deal with recursion. also, mutual recursion via global fns / closures / typeinsts
fix typeclass issues
- fix issue with passing a function as an argument where we don't know how
  many context typevars that function will need passed in
- allow default fn defs inside typeclasses
- allow typeclasses over type constructors
- allow contexts for typeinst headers
- allow constructed types in typeinst headers
implement these recommendations: https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf
- including multi-parameter type classes with functional dependencies?

add syntax for global constants
add a lexer to keep ids from running together
fix parser bug where node's empty child array leads to undefined key
add documentation
allow closures
memory management

LONG TERM IDEAS
alternative fn calling syntax: var.fn(arg) where var is passed as first arg of fn
json support
functional language constructs built in (map, filter, reduce, etc)
currying
- a(_, 23, _) means curry with 23 as the second argument
compose operator in prelude
optional, named fn arguments
by default, functions do not inherit parent scope
- also by default, no argument object / array mutation inside functions ->
- can be made a closure with =>
- can allow mutation with ->>
- or both with =>>
good namespacing / module system
- allows specifying exported types / functions
- maybe _ specifies module-private fn / data, or unmodifiable object field
- automatic documentation that scrapes comments directly above fn defs
compatible with js
- package as npm module
- can require js or bs as modules
interactive prompt
inline functions when possible
promises built in
- any function can be easily wrapped in a promise
- cancelable
- async / await or .then syntax?
immutable vars / fields?
gadts?
'memoize' fn in prelude, operates only on functional functions?
- can specify if objects returned should be copies or references
generalized ffi to easily incorporate c, python libs
json config file (e.g. detect overflow, check array bounds) for debugging vs. performance
super long-term: SIMD / GPU / FPGA support

SYNTACTIC SUGAR??
specify infix notation
operator overloading
macros
- alternative lisp output / code syntax?
js-esque bracket-based version with bjs filename
underscore_case pragma converts to camelCase behind the scenes
