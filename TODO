higher-order polymorphism, aka type constructors (e.g. arrays)
object types, with inference
- deal with object dot-access
add error handling with pretty error messages
add tests
add documentation
fix _FunctionCall_ in grammar to remove parens around nested calls
allow closures
fix type inference issues
- redefining fns means the final generalized type is not known until the last
  definition, so if we instantiate a fn before the last definition, the type
  checker will be too permissive
- ensure fn args are not generalized. particularly an issue if an arg is
  reassigned inside a fn
- deal with recursion. also, mutual recursion via global fns / closures / typeinsts
fix typeclass issues
- implement runtime overloading via dictionaries
- allow constructed types
- allow contexts for typeinst headers
- allow generalized fn defs inside typeclasses

LONG TERM IDEAS
inline functions when possible
interactive prompt
functional language constructs built in (map, filter, reduce, etc)
currying
- a(_, 23, _) means curry with 23 as the second argument
compose operator in prelude
user-defined object types
- every possible property specified
- properties optionally typed
- properties required by default, ?:: marks them optional
- type can be recursive
user-defined non-object types
- enums, with | syntax
- type constructors (e.g. maybe<int>), basically enums with arguments
- typeclasses acting on type constructors (e.g. monads)
by default, functions do not inherit parent scope
- also by default, no argument object / array mutation inside functions ->
- can be made a closure with =>
- can allow mutation with ->>
- or both with =>>
'memoize' fn in prelude, operates only on functional functions
- can specify if objects returned should be copies or references
promises built in
- any function can be easily wrapped in a promise
- cancelable
- async / await or .then syntax?
good namespacing / module system
- allows specifying exported types / functions
compatible with js
- package as npm module
- can require js or bs as modules
generalized ffi to easily incorporate c, python libs
super long-term: SIMD / GPU / FPGA support

SYNTACTIC SUGAR??
specify infix notation
operator overloading
macros
- alternative lisp output / code syntax
alternative OOP syntax where a Class translates to a module containing a type and fns
alternative fn calling syntax: var.fn(arg) where var is passed as first arg of fn
js-esque bracket-based version with bjs filename
underscore_case pragma converts to camelCase behind the scenes
