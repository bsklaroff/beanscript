parse object type in type definitions
- object type in typeclass specifies required keys
  - implemented by copying key subsets of object args
type ytype = abc {a :: atype, b :: btype}
- allow ytype k = abc {a :: k, b :: int}
- allow options, e.g. type maybe a = null | some a
  - case statements to unpack option types
  - can also unpack in fn args
  - this takes care of enums
  - question marks unpack maybes?
- allow recursive or mutually recursive types
  - disallow recursive types without maybe based on unconstructability?
typealias xtype = {a :: atype, b :: btype}
- allow xtype k = {a :: k, b :: int}
built in hashmap and hashset
implement strings
implement number types other than i32
- figure out defaulting / coercion
add error handling with pretty error messages
add documentation
fix type inference issues
- redefining fns means the final generalized type is not known until the last
  definition, so if we instantiate a fn before the last definition, the type
  checker will be too permissive
- ensure fn args are not generalized. particularly an issue if an arg is
  reassigned inside a fn
- deal with recursion. also, mutual recursion via global fns / closures / typeinsts
fix typeclass issues
- fix issue with passing a function as an argument where we don't know how
  many context typevars that function will need passed in
- allow default fn defs inside typeclasses
- allow typeclasses over type constructors
- allow contexts for typeinst headers
- allow constructed types in typeinst headers
implement these recommendations: https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf
- including multi-parameter type classes with functional dependencies?
allow closures
memory management

LONG TERM IDEAS
alternative fn calling syntax: var.fn(arg) where var is passed as first arg of fn
functional language constructs built in (map, filter, reduce, etc)
currying
- a(_, 23, _) means curry with 23 as the second argument
compose operator in prelude
can we get rid of @ symbol?
optional, named fn arguments
by default, functions do not inherit parent scope
- also by default, no argument object / array mutation inside functions ->
- can be made a closure with =>
- can allow mutation with ->>
- or both with =>>
good namespacing / module system
- allows specifying exported types / functions
- maybe _ specifies module-private fn / data, or unmodifiable object field
- automatic documentation that scrapes comments directly above fn defs
compatible with js
- package as npm module
- can require js or bs as modules
interactive prompt
inline functions when possible
promises built in
- any function can be easily wrapped in a promise
- cancelable
- async / await or .then syntax?
immutable vars / fields?
gadts?
'memoize' fn in prelude, operates only on functional functions?
- can specify if objects returned should be copies or references
generalized ffi to easily incorporate c, python libs
json config file (e.g. detect overflow, check array bounds) for debugging vs. performance
super long-term: SIMD / GPU / FPGA support

SYNTACTIC SUGAR??
specify infix notation
operator overloading
macros
- alternative lisp output / code syntax?
js-esque bracket-based version with bjs filename
underscore_case pragma converts to camelCase behind the scenes
