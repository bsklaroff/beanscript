type Maybe a = Null | Just a

typeclass Show a
  print :: a -> Void

typeclass Eq a <= (Show)
  __eq__ :: a -> a -> Bool
  __neq__ :: a -> a -> Bool

typeclass Cmp a <= (Eq)
  __lt__ :: a -> a -> Bool
  __lte__ :: a -> a -> Bool
  __gt__ :: a -> a -> Bool
  __gte__ :: a -> a -> Bool

typeclass Num a <= (Cmp)
  __add__ :: a -> a -> a
  __sub__ :: a -> a -> a
  __mul__ :: a -> a -> a
  __div__ :: a -> a -> a
  __neg__ :: a -> a

typeinst Num I32
  print: (x) ->
    ((i32.store (i32.const 0) x))
    ((call $print (i32.const 0)))
  __eq__: (x, y) -> ((i32.eq x y))
  __neq__: (x, y) -> ((i32.ne x y))
  __lt__: (x, y) -> ((i32.lt_s x y))
  __lte__: (x, y) -> ((i32.le_s x y))
  __gt__: (x, y) -> ((i32.gt_s x y))
  __gte__: (x, y) -> ((i32.ge_s x y))
  __add__: (x, y) -> ((i32.add x y))
  __sub__: (x, y) -> ((i32.sub x y))
  __mul__: (x, y) -> ((i32.mul x y))
  __div__: (x, y) -> ((i32.div_s x y))
  __neg__: (x) -> ((i32.sub (i32.const 0) x))

typeinst Num I64
  print: (x) ->
    ((i64.store (i32.const 0) x))
    ((call $print (i32.const 1)))
  __eq__: (x, y) -> ((i64.eq x y))
  __neq__: (x, y) -> ((i64.ne x y))
  __lt__: (x, y) -> ((i64.lt_s x y))
  __lte__: (x, y) -> ((i64.le_s x y))
  __gt__: (x, y) -> ((i64.gt_s x y))
  __gte__: (x, y) -> ((i64.ge_s x y))
  __add__: (x, y) -> ((i64.add x y))
  __sub__: (x, y) -> ((i64.sub x y))
  __mul__: (x, y) -> ((i64.mul x y))
  __div__: (x, y) -> ((i64.div_s x y))
  __neg__: (x) -> ((i64.sub (i64.const 0) x))

typeinst Eq Bool
  print: (x) ->
    ((i32.store (i32.const 0) x))
    ((call $print (i32.const 2)))
  __eq__: (x, y) -> ((i32.eq x y))
  __neq__: (x, y) -> ((i32.ne x y))

###
Array functions
###

len :: Arr a -> I32
len = (arr) -> ((i32.load &arr))

# TODO: check array bounds
__arr_set__ :: Arr a -> I32 -> a -> Void
__arr_set__ = (arr, idx, val) ->
  data_start = ((i32.load (i32.add &arr (i32.const 8))))
  heap_loc = data_start + idx * 4
  ((i32.store heap_loc &val))

# TODO: check array bounds
__arr_get__ :: Arr a -> I32 -> a
__arr_get__ = (arr, idx) ->
  data_start = ((i32.load (i32.add &arr (i32.const 8))))
  heap_loc = data_start + idx * 4
  return_ptr ((i32.load heap_loc))

push :: Arr a -> a -> Void
push = (arr, val) ->
  arr_len = len(arr)
  allocated = ((i32.load (i32.add &arr (i32.const 4))))
  if arr_len == allocated
    _reallocate(arr)
  new_arr_len = arr_len + 1
  ((i32.store &arr new_arr_len))
  data_start = ((i32.load (i32.add &arr (i32.const 8))))
  heap_loc = data_start + (new_arr_len - 1) * 4
  ((i32.store heap_loc &val))

_reallocate :: Arr a -> Void
_reallocate = (arr) ->
  new_data_start = ((get_global $hp))
  arr_len = len(arr)
  i = 0
  while i < arr_len
    val = arr[i]
    new_heap_loc = new_data_start + i * 4
    ((i32.store new_heap_loc &val))
    i = i + 1
  new_allocated = 2 * (arr_len + 1)
  new_hp = new_data_start + new_allocated * 4
  ((i32.store (i32.add &arr (i32.const 4)) new_allocated))
  ((i32.store (i32.add &arr (i32.const 8)) new_data_start))
  ((set_global $hp new_hp))

pop :: Arr a -> a
pop = (arr) ->
  arr_len = len(arr)
  new_arr_len = arr_len - 1
  data_start = ((i32.load (i32.add &arr (i32.const 8))))
  heap_loc = data_start + new_arr_len * 4
  ((i32.store &arr new_arr_len))
  return_ptr ((i32.load heap_loc))

